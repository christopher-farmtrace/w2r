<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>SA / ZW ID Barcode Autofill</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 16px; background: #f5f5f5; }
    .card { border: 1px solid #ddd; border-radius: 12px; padding: 14px; margin-bottom: 14px; background: #fff; }
    label { display:block; font-size: 12px; opacity:.8; margin: 10px 0 4px; }
    input, select, textarea { width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 10px; font-size: 16px; box-sizing: border-box; }
    .row { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    button { padding: 10px 12px; border-radius: 10px; border: 1px solid #333; background: #111; color: white; font-size: 16px; cursor: pointer; }
    button.secondary { background: white; color: #111; }
    button:disabled { opacity: .4; cursor: not-allowed; }
    .hint { font-size: 13px; opacity: .8; line-height: 1.4; }
    .ok { color: #0a7; font-weight: 600; }
    .bad { color: #c22; font-weight: 600; }
    .warn { color: #b85c00; font-weight: 600; }
    .stepper { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .pill { font-size: 12px; padding: 6px 10px; border-radius: 999px; border: 1px solid #ddd; }
    .pill.active { border-color:#111; background:#111; color:#fff; }
    #scanCapture { position: fixed; left: -9999px; top: -9999px; opacity: 0; height: 1px; width: 1px; }
    pre { white-space: pre-wrap; word-break: break-word; background: #fafafa; border: 1px solid #eee; border-radius: 10px; padding: 10px; margin: 0; }
    .footer-actions { display:flex; gap:10px; flex-wrap:wrap; margin-top: 12px; }
    .hidden { display:none !important; }
    .muted { opacity:.75; }
    #placesStatus { font-size: 12px; margin-top: 4px; min-height: 18px; }
    .pac-container { z-index: 9999; }

    /* â”€â”€ Camera button â”€â”€ */
    #cameraBtn {
      display: inline-flex; align-items: center; gap: 8px;
      background: #0057d8; border-color: #0046b0;
    }
    #cameraBtn svg { flex-shrink: 0; }
    #cameraBtn:disabled { background: #666; border-color: #555; }

    /* â”€â”€ Scanbot test button â”€â”€ */
    #scanbotBtn {
      display: inline-flex; align-items: center; gap: 8px;
      background: #b8000a; border-color: #8c0008; color: #fff;
    }
    #scanbotBtn svg { flex-shrink: 0; }
    #scanbotBtn:disabled { background: #666; border-color: #555; }

    /* â”€â”€ Fullscreen scanner overlay â”€â”€ */
    #scanOverlay {
      position: fixed; inset: 0; z-index: 1000;
      background: #000;
      display: flex; flex-direction: column;
      align-items: center; justify-content: flex-end;
      padding-bottom: 48px;
    }
    #scanOverlay.hidden { display: none !important; }

    #cameraFeed {
      position: absolute; inset: 0;
      width: 100%; height: 100%;
      object-fit: cover;
    }

    .scan-label {
      position: relative; z-index: 2;
      color: rgba(255,255,255,0.9);
      font-size: 13px; text-align: center;
      padding: 0 24px;
      text-shadow: 0 1px 4px rgba(0,0,0,0.8);
    }

    #scanMsg {
      position: relative; z-index: 2;
      font-size: 13px; font-weight: 600;
      text-align: center;
      margin-top: 10px; padding: 7px 20px;
      border-radius: 999px;
      background: rgba(0,0,0,0.5);
      color: #fff; min-height: 32px;
      transition: background 0.2s;
    }
    #scanMsg.ok-msg  { background: rgba(0,148,80,0.8); }
    #scanMsg.bad-msg { background: rgba(190,30,30,0.8); }

    .scan-actions {
      position: relative; z-index: 2;
      display: flex; gap: 12px; margin-top: 18px;
    }
    .scan-actions button { padding: 11px 22px; font-size: 15px; border-radius: 12px; }
    #closeScanBtn { background: rgba(255,255,255,0.14); border-color: rgba(255,255,255,0.3); color: #fff; }
    #torchBtn     { background: rgba(255,200,0,0.16);  border-color: rgba(255,200,0,0.4);  color: #ffe; }
    #torchBtn.lit { background: rgba(255,200,0,0.55); }

    @keyframes successFlash {
      0%   { background: rgba(0,220,100,0.0); }
      20%  { background: rgba(0,220,100,0.5); }
      100% { background: rgba(0,220,100,0.0); }
    }
    .flash-layer {
      position: fixed; inset: 0; z-index: 1001; pointer-events: none;
      animation: successFlash 0.65s ease-out forwards;
    }
  </style>
</head>
<body>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• CAMERA OVERLAY â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div id="scanOverlay" class="hidden" role="dialog" aria-modal="true" aria-label="Barcode Scanner">
  <video id="cameraFeed" playsinline muted autoplay></video>
  <div class="scan-label">Point camera at the PDF417 barcode (back of SA or Zimbabwe ID)</div>
  <div id="scanMsg">Initialisingâ€¦</div>
  <div class="scan-actions">
    <button id="torchBtn" type="button">ğŸ”¦ Torch</button>
    <button id="closeScanBtn" type="button">âœ• Cancel</button>
  </div>
</div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• MAIN APP â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div class="card">
  <div class="stepper" style="margin-bottom:10px;">
    <span class="pill active" id="pill1">Step 1: Scan ID</span>
    <span class="pill" id="pill2">Step 2: Extra details</span>
  </div>

  <h2 style="margin:0 0 8px;">Barcode â†’ Form Autofill</h2>
  <div class="hint">
    Tap <b>Scan with Camera</b> to use your phone's camera on the PDF417 barcode on the
    <b>back</b> of the SA or Zimbabwe ID. Or use a Bluetooth / USB barcode scanner with <b>Scanner</b>.
    The app auto-detects whether the barcode is a South African ID (13-digit number) or a
    Zimbabwean ID (format <code>XX-XXXXXXA-XX</code>) and fills the form accordingly.
  </div>

  <div style="margin-top:12px; display:flex; gap:10px; flex-wrap:wrap;">
    <button id="cameraBtn" type="button">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/>
        <circle cx="12" cy="13" r="4"/>
      </svg>
      Scan with Camera
    </button>
    <button id="scanbotBtn" type="button">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <rect x="3" y="3" width="18" height="18" rx="2"/><line x1="3" y1="9" x2="21" y2="9"/><line x1="3" y1="15" x2="21" y2="15"/><line x1="9" y1="3" x2="9" y2="21"/><line x1="15" y1="3" x2="15" y2="21"/>
      </svg>
      Scanbot (Test)
    </button>
    <button id="startBtn" class="secondary" type="button">Scanner</button>
    <button id="clearBtn" class="secondary" type="button">Clear</button>
  </div>

  <div style="margin-top:10px;" id="status"></div>
  <textarea id="scanCapture" autocomplete="off" autocapitalize="off" spellcheck="false"></textarea>
</div>

<!-- STEP 1 -->
<div class="card" id="step1">
  <h3 style="margin:0 0 8px;">Step 1: Staff Details (autofill)</h3>

  <label>Surname</label>
  <input id="surname" />

  <label>Names</label>
  <input id="names" />

  <div class="row">
    <div>
      <label>Gender</label>
      <select id="gender">
        <option value=""></option>
        <option value="M">M</option>
        <option value="F">F</option>
      </select>
    </div>
    <div>
      <label>ID Number</label>
      <input id="idNumber" inputmode="numeric" />
    </div>
  </div>

  <div class="row">
    <div>
      <label>Date of Birth</label>
      <input id="dob" placeholder="YYYY-MM-DD" />
    </div>
    <div>
      <label>Citizenship</label>
      <input id="citizenship" placeholder="CITIZEN / PERMANENT RESIDENT / ..." />
    </div>
  </div>

  <div class="row">
    <div>
      <label>Nationality (scanned)</label>
      <input id="nationality" placeholder="SA / RSA / ..." />
    </div>
    <div>
      <label>Issue Date</label>
      <input id="issueDate" placeholder="YYYY-MM-DD" />
    </div>
  </div>

  <div class="footer-actions">
    <button id="nextStepBtn" type="button">Next step â†’</button>
  </div>
  <div class="hint muted" style="margin-top:8px;">
    Tip: The app auto-detects SA IDs (13-digit number) and Zimbabwe IDs (e.g. <code>63-123456A07</code>). Check the Debug section if scanning produces unexpected results.
  </div>
</div>

<!-- STEP 2 -->
<div class="card hidden" id="step2">
  <h3 style="margin:0 0 8px;">Step 2: Extra details (manual)</h3>

  <div class="row">
    <div>
      <label>Race</label>
      <select id="race">
        <option value=""></option>
        <option value="African">African</option>
        <option value="Asian">Asian</option>
        <option value="Coloured">Coloured</option>
        <option value="Indian">Indian</option>
        <option value="White">White</option>
      </select>
    </div>
    <div>
      <label>Language</label>
      <select id="language">
        <option value=""></option>
        <option value="Afrikaans">Afrikaans</option>
        <option value="English">English</option>
        <option value="Ndelebele">Ndelebele</option>
        <option value="Other">Other</option>
        <option value="Sepedi">Sepedi</option>
        <option value="Siswati">Siswati</option>
      </select>
    </div>
  </div>

  <label>Marital Status</label>
  <select id="maritalStatus">
    <option value=""></option>
    <option value="Single">Single</option>
    <option value="Married">Married</option>
  </select>

  <h4 style="margin:14px 0 6px;">Address details</h4>

  <label>Search address <span class="hint muted" style="display:inline;">(type to autocomplete)</span></label>
  <input id="placesSearch" placeholder="e.g. 12 Main Street, Sandton" autocomplete="off" />
  <div id="placesStatus"></div>

  <label>Country</label>
  <input id="addrCountry" placeholder="e.g. South Africa" />

  <div class="row">
    <div>
      <label>Street Number</label>
      <input id="streetNumber" inputmode="numeric" />
    </div>
    <div>
      <label>Street Name</label>
      <input id="streetName" />
    </div>
  </div>

  <label>Suburb</label>
  <input id="suburb" />

  <div class="row">
    <div>
      <label>City/Town</label>
      <input id="cityTown" />
    </div>
    <div>
      <label>Province</label>
      <input id="province" />
    </div>
  </div>

  <label>Postal Code</label>
  <input id="postalCode" inputmode="numeric" />

  <div class="footer-actions">
    <button id="backBtn" class="secondary" type="button">â† Back</button>
    <button id="submitBtn" type="button">Submit</button>
  </div>

  <div class="hint muted" style="margin-top:8px;">
    Submit will post the payload to DBFlex if <code>#authToken=â€¦&amp;dbId=â€¦</code> are present in the URL, otherwise output JSON to the Debug panel.
  </div>
  <div id="apiStatus" style="margin-top:8px; font-size:13px; min-height:18px;"></div>
</div>

<!-- SETTINGS -->
<div class="card" id="settingsCard">
  <details id="settingsDetails">
    <summary style="cursor:pointer; font-weight:600; font-size:15px; list-style:none; display:flex; align-items:center; gap:8px;">
      <span>âš™ Settings</span>
      <span id="apiKeyBadge" style="font-size:11px; padding:3px 8px; border-radius:999px; background:#eee; color:#555; font-weight:400;"></span>
    </summary>

    <div style="margin-top:12px;">
      <label style="font-weight:600;">Google Maps API Key</label>
      <div class="hint muted" style="margin-bottom:6px;">
        Stored in your browser's localStorage â€” never sent anywhere except Google's API.
        Get a key at <a href="https://console.cloud.google.com/apis/credentials" target="_blank" rel="noopener">console.cloud.google.com</a>.
      </div>
      <div style="display:flex; gap:8px; align-items:stretch;">
        <input id="apiKeyInput" type="password" placeholder="AIzaâ€¦" autocomplete="off" spellcheck="false"
               style="font-family:monospace; flex:1;" />
        <button id="apiKeyToggle" class="secondary" type="button" style="width:44px; padding:10px 0; flex-shrink:0;" title="Show/hide key">ğŸ‘</button>
      </div>
      <div style="display:flex; gap:8px; margin-top:8px; flex-wrap:wrap;">
        <button id="apiKeySave" type="button">Save &amp; activate</button>
        <button id="apiKeyClear" class="secondary" type="button">Clear saved key</button>
      </div>
      <div id="apiKeyStatus" style="font-size:12px; margin-top:6px; min-height:16px;"></div>
    </div>
  </details>
</div>

<!-- DEBUG -->
<div class="card">
  <h3 style="margin:0 0 8px;">Debug</h3>
  <div class="hint">Raw scan, parsed fields, and (on Submit) the final payload.</div>
  <label>Raw scan</label>
  <pre id="rawOut">(none yet)</pre>
  <label style="margin-top:10px;">Fields detected</label>
  <pre id="fieldsOut">(none yet)</pre>
  <label style="margin-top:10px;">Submit payload</label>
  <pre id="payloadOut">(submit to view payload)</pre>
</div>

<!--
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  BARCODE ENGINE LOADER
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  Strategy (in priority order):
    1. Native BarcodeDetector API w/ pdf417 support  (Chrome Android â‰¥83, some desktop Chrome)
    2. @zxing/browser BrowserPDF417Reader            (iOS Safari, Firefox, older Android Chrome)
       â€“ modern, maintained replacement for @zxing/library
       â€“ uses the continuous video decode path, NOT the broken
         manual BinaryBitmap path from the old library
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-->
<script>
  // Lazy-load @zxing/browser (UMD bundle exposes window.ZXingBrowser)
  let _zxingBrowserPromise = null;
  function loadZXingBrowser() {
    if (_zxingBrowserPromise) return _zxingBrowserPromise;
    _zxingBrowserPromise = new Promise((resolve, reject) => {
      const s = document.createElement('script');
      // @zxing/browser 0.1.5 â€“ correct UMD bundle path on unpkg
      s.src = 'https://unpkg.com/@zxing/browser@0.1.5/umd/zxing-browser.min.js';
      s.onload  = () => resolve(window.ZXingBrowser);
      s.onerror = () => reject(new Error('Failed to load @zxing/browser barcode library'));
      document.head.appendChild(s);
    });
    return _zxingBrowserPromise;
  }
</script>

<!-- â”€â”€ Scanbot Web SDK â€” lazy-loaded on first use â”€â”€ -->
<script>
  let _scanbotSdkInstance = null;
  let _scanbotLoadPromise = null;

  function loadAndInitScanbot() {
    if (_scanbotLoadPromise) return _scanbotLoadPromise;
    _scanbotLoadPromise = new Promise((resolve, reject) => {
      const s = document.createElement('script');
      // ui2 bundle is required for the Ready-To-Use UI components (createBarcodeScanner)
      s.src = 'https://cdn.jsdelivr.net/npm/scanbot-web-sdk@7.1.0/bundle/ScanbotSDK.ui2.min.js';
      s.onload = async () => {
        try {
          _scanbotSdkInstance = await window.ScanbotSDK.initialize({
            licenseKey: '', // empty = 60-second trial mode per session
            // enginePath tells the SDK where to load its WASM workers from
            enginePath: 'https://cdn.jsdelivr.net/npm/scanbot-web-sdk@7.1.0/bundle/bin/complete/'
          });
          resolve(_scanbotSdkInstance);
        } catch (e) {
          reject(e);
        }
      };
      s.onerror = () => reject(new Error('Failed to load Scanbot SDK from CDN'));
      document.head.appendChild(s);
    });
    return _scanbotLoadPromise;
  }
</script>

<script>
(function () {
  'use strict';

  // â”€â”€ CONFIG â€” key lives in localStorage, never in source code â”€
  const LS_KEY    = 'gmaps_api_key';
  const getApiKey = () => localStorage.getItem(LS_KEY) || '';

  const XOR_KEY = 'Ry9s867aaMbP1srGX9hP3v87rtH49ENgFg7XGBgFXAdbvt4Y1ptVuGpApvPxQRJA';

  function xorObfuscate(plaintext) {
    const key = XOR_KEY;
    return Array.from(plaintext)
      .map((ch, i) => ch.charCodeAt(0) ^ key.charCodeAt(i % key.length))
      .map(b => b.toString(16).padStart(2, '0'))
      .join('');
  }

  function xorDeobfuscate(hex) {
    const key = XOR_KEY;
    const bytes = hex.match(/.{2}/g) || [];
    return bytes
      .map((b, i) => String.fromCharCode(parseInt(b, 16) ^ key.charCodeAt(i % key.length)))
      .join('');
  }

  // â”€â”€ Nationality â†’ ISO-2 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const NAT_MAP = {
    'SA':'za','RSA':'za','ZA':'za','SOUTH AFRICA':'za','SOUTH AFRICAN':'za',
    'NAM':'na','NAMIBIA':'na','NAMIBIAN':'na',
    'ZWE':'zw','ZIMBABWE':'zw','ZIMBABWEAN':'zw',
    'MOZ':'mz','MOZAMBIQUE':'mz','MOZAMBICAN':'mz',
    'BWA':'bw','BOTSWANA':'bw','MOTSWANA':'bw',
    'ZMB':'zm','ZAMBIA':'zm','ZAMBIAN':'zm',
    'MWI':'mw','MALAWI':'mw','MALAWIAN':'mw',
    'SWZ':'sz','ESWATINI':'sz','SWAZILAND':'sz',
    'LSO':'ls','LESOTHO':'ls','BASOTHO':'ls',
    'GBR':'gb','UK':'gb','UNITED KINGDOM':'gb','BRITISH':'gb',
    'USA':'us','US':'us','UNITED STATES':'us','AMERICAN':'us',
    'IND':'in','INDIA':'in','INDIAN':'in',
    'CHN':'cn','CHINA':'cn','CHINESE':'cn',
    'PRT':'pt','PORTUGAL':'pt','PORTUGUESE':'pt',
  };
  const natToIso2 = raw => raw ? (NAT_MAP[raw.trim().toUpperCase()] || null) : null;

  // â”€â”€ Element refs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const $ = id => document.getElementById(id);

  const scanCapture  = $('scanCapture');
  const status       = $('status');
  const rawOut       = $('rawOut');
  const fieldsOut    = $('fieldsOut');
  const payloadOut   = $('payloadOut');
  const placesSearch = $('placesSearch');
  const placesStatus = $('placesStatus');

  // Camera overlay
  const scanOverlay  = $('scanOverlay');
  const cameraFeed   = $('cameraFeed');
  const scanMsg      = $('scanMsg');
  const torchBtn     = $('torchBtn');

  // â”€â”€ State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  let buffer = '', flushTimer = null;
  let placesAC = null, placesSvc = null;

  // Camera
  let cameraStream    = null;
  let scanLoopHandle  = null;   // rAF id, interval id, or ZXing reader ref
  let scanEngine      = null;   // 'native' | 'zxing-browser'
  let nativeDet       = null;
  let zxingReader     = null;   // BrowserPDF417Reader instance
  let torchOn         = false;
  let torchTrack      = null;
  let lastResult      = null;
  let lastResultTime  = 0;

  // â”€â”€ UI helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function setStatus(msg, ok = true) {
    status.innerHTML = `<span class="${ok ? 'ok' : 'bad'}">${msg}</span>`;
  }
  function setPlacesStatus(msg, type = 'ok') {
    placesStatus.innerHTML = msg ? `<span class="${type}">${msg}</span>` : '';
  }
  function setScanMsg(msg, type = '') {
    scanMsg.textContent = msg;
    scanMsg.className = type === 'ok' ? 'ok-msg' : type === 'bad' ? 'bad-msg' : '';
  }

  // â”€â”€ Step navigation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function setStep(n) {
    $('step1').classList.toggle('hidden', n !== 1);
    $('step2').classList.toggle('hidden', n !== 2);
    $('pill1').classList.toggle('active', n === 1);
    $('pill2').classList.toggle('active', n === 2);
    if (n === 2) { scanCapture.blur(); applyCountryFromNationality(); }
    window.scrollTo({ top: 0, behavior: 'smooth' });
  }

  function applyCountryFromNationality() {
    if (!placesAC) return;
    const raw  = $('nationality').value;
    const iso2 = natToIso2(raw);
    if (iso2) {
      placesAC.setComponentRestrictions({ country: iso2 });
      setPlacesStatus(`Address search restricted to <b>${iso2.toUpperCase()}</b> (from "${raw}")`, 'ok');
    } else {
      placesAC.setComponentRestrictions({});
      setPlacesStatus(raw ? `No country mapping for "${raw}" â€” searching globally` : 'No nationality scanned â€” searching globally', 'warn');
    }
  }

  // â”€â”€ Clear â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function clearAll() {
    buffer = ''; scanCapture.value = '';
    rawOut.textContent = '(none yet)';
    fieldsOut.textContent = '(none yet)';
    payloadOut.textContent = '(submit to view payload)';
    placesSearch.value = ''; setPlacesStatus('');
    ['surname','names','gender','idNumber','dob','citizenship','nationality','issueDate',
     'race','language','maritalStatus','addrCountry','streetNumber','streetName',
     'suburb','cityTown','province','postalCode'
    ].forEach(id => { const el = $(id); if (el) el.value = ''; });
    setStatus('Cleared.', true);
    setStep(1);
  }

  // â”€â”€ Barcode text â†’ form â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function normalizeWS(s) {
    return s.replace(/\r/g,'\n').replace(/\t/g,'\n').replace(/[ ]{2,}/g,' ').trim();
  }
  function splitFields(s) {
    if (/\n/.test(s)) return s.split('\n').map(p => p.trim()).filter(Boolean);
    if (s.includes('|')) return s.split('|').map(p => p.trim()).filter(Boolean);
    return s.split(/\s*\|\s*|\s{2,}/).map(p => p.trim()).filter(Boolean);
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // PER-COUNTRY PARSERS
  // Each parser is self-contained:
  //   detect*(parts, rawText) â†’ boolean   â€” is this barcode mine?
  //   parse*(parts)           â†’ fields    â€” extract fields, no defaults from other countries
  // detectAndParse() calls detect* in priority order and hands off to the matching parser.
  // If nothing matches, it returns empty fields and type 'UNKNOWN'.
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  // â”€â”€ Shared date helpers (pure, no country coupling) â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const isDateWords    = v => /^\d{2}\s+[A-Z]{3}\s+\d{4}$/i.test((v||'').trim());
  const parseDW        = v => {
    const m = (v||'').trim().toUpperCase().match(/^(\d{2})\s+([A-Z]{3})\s+(\d{4})$/);
    if (!m) return '';
    const MM = {JAN:'01',FEB:'02',MAR:'03',APR:'04',MAY:'05',JUN:'06',
                JUL:'07',AUG:'08',SEP:'09',OCT:'10',NOV:'11',DEC:'12'}[m[2]]||'';
    return MM ? `${m[3]}-${MM}-${m[1]}` : '';
  };
  const parseDateNumeric = v => {
    if (!v) return '';
    const s = v.trim();
    let m = s.match(/^(\d{4})(\d{2})(\d{2})$/);        if (m) return `${m[1]}-${m[2]}-${m[3]}`;
    m = s.match(/^(\d{4})[-/](\d{2})[-/](\d{2})$/);    if (m) return `${m[1]}-${m[2]}-${m[3]}`;
    m = s.match(/^(\d{2})[-/](\d{2})[-/](\d{4})$/);    if (m) return `${m[3]}-${m[2]}-${m[1]}`;
    return '';
  };
  const parseDate = v => isDateWords(v) ? parseDW(v) : parseDateNumeric(v);

  // â”€â”€ Blank result template â€” every parser starts from this â”€â”€â”€
  const blankFields = () => ({
    surname:'', names:'', gender:'', nationality:'',
    idNumber:'', dob:'', citizenship:'', issueDate:'',
  });

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // SOUTH AFRICA
  // Detection: exactly one 13-digit numeric field (the SA ID number).
  // Format:    positional, no labels.
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  const SA_ID_RE = /^\d{13}$/;

  function detectSA(parts) {
    return parts.some(p => SA_ID_RE.test(p.replace(/\s/g, '')));
  }

  function parseSA(parts) {
    const out = blankFields();
    const isGender = v => /^[MF]$/i.test((v||'').trim());

    const idx = parts.findIndex(p => SA_ID_RE.test(p.replace(/\s/g,'')));
    out.idNumber = idx >= 0 ? parts[idx].replace(/\s/g,'') : '';

    out.surname     = parts[0] || '';
    out.names       = parts[1] || '';
    if (isGender(parts[2])) out.gender = parts[2].toUpperCase();
    out.nationality = parts[3] || '';
    const dobRaw    = parts[5] || '';
    out.citizenship = parts[7] || '';
    const issueRaw  = parts[8] || '';

    if (idx >= 0) {
      if ((!out.nationality || out.nationality.length > 10) && parts[idx-1])
        out.nationality = parts[idx-1];
      if (!dobRaw   && parts[idx+1]) out.dob       = parseDate(parts[idx+1]);
      if (!out.citizenship && parts[idx+3]) out.citizenship = parts[idx+3];
      if (!issueRaw && parts[idx+4]) out.issueDate = parseDate(parts[idx+4]);
      if (!out.gender) { const g = parts.find(isGender); if (g) out.gender = g.toUpperCase(); }
    }
    if (dobRaw)   out.dob       = parseDate(dobRaw);
    if (issueRaw) out.issueDate = parseDate(issueRaw);

    return out;
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ZIMBABWE
  // Detection: presence of a ZW-format ID number (XX-XXXXXXA-XX) OR
  //            at least two ZW-specific labelled fields ("Surname:", "Birth date:", etc.).
  //            Never triggered by SA-format barcodes.
  // Format:    labelled ("Label: Value"), with a positional fallback.
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  // ZW ID: 2-digit registrar Â· 6-7 digit serial Â· alpha check Â· 2-digit district
  // May be written with hyphens, spaces, or nothing between parts.
  // Must NOT match a 13-digit SA ID â€” the alpha check letter distinguishes it.
  const ZW_ID_RE = /\b\d{2}[-\s]?\d{6,7}[-\s]?[A-Z][-\s]?\d{2}\b/i;

  // ZW barcode label keywords â€” used for detection and for labelled-field parsing.
  // These are ZW-specific; none of them appear in SA barcodes.
  const ZW_LABELS = ['surname','first name','birth date','village of origin','place of birth','issue date','national id'];

  function extractZimId(s) {
    const m = (s||'').match(ZW_ID_RE);
    return m ? m[0].replace(/\s/g,'').toUpperCase() : null;
  }

  function detectZW(parts) {
    // Signal 1: a ZW-format ID number exists in any field value
    if (parts.some(p => ZW_ID_RE.test(p))) return true;
    // Signal 2: at least two ZW-specific labels are present (guards against single-word coincidences)
    const labelHits = parts.filter(p => {
      const lbl = (p.split(':')[0] || '').trim().toLowerCase();
      return ZW_LABELS.includes(lbl);
    });
    return labelHits.length >= 2;
  }

  function parseZW(parts) {
    // â”€â”€ Build label â†’ raw-value map â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const labeled = {};
    parts.forEach(p => {
      const m = p.match(/^([^:]{1,40}):\s*(.*)$/);
      if (m) labeled[m[1].trim().toLowerCase()] = m[2].trim();
    });

    // Lookup helper â€” checks exact key, then partial includes, in priority order
    function get(...keys) {
      for (const k of keys) {
        if (labeled[k] !== undefined) return labeled[k];
      }
      // Partial match fallback
      for (const k of keys) {
        const found = Object.keys(labeled).find(lk => lk.includes(k));
        if (found !== undefined) return labeled[found];
      }
      return null; // explicit null = "not present in this barcode"
    }

    const out = blankFields();
    // nationality stays '' â€” ZW barcodes don't encode it; callers see '' not a forced default

    // ID Number field may carry trailing tokens:  "63-1234567 B 00 CIT M"
    const rawIdField = get('id number', 'national id', 'id no');
    if (rawIdField !== null) {
      out.idNumber = extractZimId(rawIdField) || '';
      const afterId = rawIdField.replace(ZW_ID_RE, '').trim();
      if (afterId) {
        const tokens = afterId.split(/\s+/);
        // Last token is gender (M/F) if it matches
        if (/^[MF]$/i.test(tokens[tokens.length - 1])) {
          out.gender = tokens.pop().toUpperCase();
        }
        // Remaining tokens are citizenship
        if (tokens.length) out.citizenship = tokens.join(' ');
      }
    }

    out.surname = get('surname', 'last name', 'family name') ?? '';
    out.names   = get('first name', 'forename', 'given name', 'names') ?? '';

    // Gender from dedicated field takes precedence over the hint extracted above
    const rawGender = get('gender', 'sex');
    if (rawGender !== null) out.gender = rawGender.toUpperCase().charAt(0);

    const dobRaw   = get('birth date', 'date of birth', 'dob') ?? '';
    out.dob        = parseDate(dobRaw);

    const issueRaw = get('issue date', 'date of issue') ?? '';
    out.issueDate  = parseDate(issueRaw);

    // Explicit citizenship field wins over the hint already set from ID field
    const citField = get('citizenship', 'citizen status');
    if (citField !== null) out.citizenship = citField;

    // â”€â”€ Positional fallback if labelled parsing produced no ID â”€â”€
    // (handles ZW barcodes that omit labels but still use ZW ID format)
    if (!out.idNumber) {
      return parseZWPositional(parts);
    }

    return out;
  }

  function parseZWPositional(parts) {
    const out = blankFields();
    const isGender = v => /^[MF]$/i.test((v||'').trim());
    let dobRaw = '', issueRaw = '';

    for (const p of parts) {
      const id = extractZimId(p);
      if (id && !out.idNumber) {
        out.idNumber = id;
        // Check for trailing gender / citizenship tokens
        const after = p.replace(ZW_ID_RE, '').trim();
        if (after) {
          const tokens = after.split(/\s+/);
          if (/^[MF]$/i.test(tokens[tokens.length - 1])) out.gender = tokens.pop().toUpperCase();
          if (tokens.length) out.citizenship = tokens.join(' ');
        }
        continue;
      }
      if (isGender(p) && !out.gender)  { out.gender = p.toUpperCase(); continue; }
      if (parseDate(p))                 {
        if (!dobRaw) { dobRaw = p; continue; }
        if (!issueRaw) { issueRaw = p; continue; }
      }
      if (!out.surname) { out.surname = p; continue; }
      if (!out.names)   { out.names   = p; continue; }
    }

    out.dob       = parseDate(dobRaw);
    out.issueDate = parseDate(issueRaw);
    return out;
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // DISPATCHER â€” strict detection, no cross-country fallback defaults
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  function detectAndParse(parts, rawText) {
    if (detectZW(parts))  return { data: parseZW(parts),  type: 'ZW' };
    if (detectSA(parts))  return { data: parseSA(parts),  type: 'SA' };
    return { data: blankFields(), type: 'UNKNOWN' };
  }

  function fillStep1(d) {
    if (d.surname)     $('surname').value     = d.surname;
    if (d.names)       $('names').value       = d.names;
    if (d.gender)      $('gender').value      = d.gender;
    if (d.nationality) $('nationality').value = d.nationality;
    if (d.idNumber)    $('idNumber').value    = d.idNumber;
    if (d.dob)         $('dob').value         = d.dob;
    if (d.citizenship) $('citizenship').value = d.citizenship;
    if (d.issueDate)   $('issueDate').value   = d.issueDate;
  }

  function parseAndApply(raw) {
    const n = normalizeWS(raw);
    rawOut.textContent = n || '(empty)';
    const parts = splitFields(n);
    fieldsOut.textContent = parts.map((p,i) => `[${i}] ${p}`).join('\n') || '(no fields)';
    const { data, type } = detectAndParse(parts, n);
    fillStep1(data);
    if (type === 'UNKNOWN') {
      setStatus('Scan captured, but ID type not recognised. Check Debug.', false);
    } else if (data.idNumber) {
      setStatus(`Scan captured (${type} ID) â€” Step 1 autofilled`, true);
    } else {
      setStatus(`Scan captured (${type} ID detected) but ID number missing. Check Debug.`, false);
    }
  }

  // â”€â”€ Keyboard wedge scanner â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function scheduleFlush() {
    if (flushTimer) clearTimeout(flushTimer);
    flushTimer = setTimeout(() => {
      if (buffer.trim()) { parseAndApply(buffer); buffer = ''; scanCapture.value = ''; }
    }, 120);
  }
  scanCapture.addEventListener('keydown', e => {
    if (e.key === 'Enter' || e.key === 'Tab') {
      e.preventDefault();
      const raw = (buffer + (scanCapture.value ? '\n'+scanCapture.value : '')).trim();
      if (raw) parseAndApply(raw);
      buffer = ''; scanCapture.value = ''; return;
    }
    scheduleFlush();
  });
  scanCapture.addEventListener('input', () => { buffer = scanCapture.value; scheduleFlush(); });

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // CAMERA SCANNER â€” fixed engine selection
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  // Pick the best available engine:
  //  â€¢ 'native'       â€” BarcodeDetector API with pdf417 support
  //  â€¢ 'zxing-browser' â€” @zxing/browser BrowserPDF417Reader (all other browsers)
  async function pickEngine() {
    if ('BarcodeDetector' in window) {
      try {
        const fmts = await BarcodeDetector.getSupportedFormats();
        if (fmts.includes('pdf417')) {
          nativeDet = new BarcodeDetector({ formats: ['pdf417'] });
          return 'native';
        }
      } catch(_) {}
    }
    // Load modern @zxing/browser (NOT the old broken @zxing/library)
    await loadZXingBrowser();
    return 'zxing-browser';
  }

  function flashSuccess() {
    const div = document.createElement('div');
    div.className = 'flash-layer';
    document.body.appendChild(div);
    setTimeout(() => div.remove(), 700);
  }

  function onBarcode(text) {
    const now = Date.now();
    if (text === lastResult && now - lastResultTime < 3000) return; // debounce repeats
    lastResult = text; lastResultTime = now;
    flashSuccess();
    setScanMsg('Barcode detected âœ“', 'ok');
    setTimeout(() => {
      stopCamera();
      parseAndApply(text);
      setStatus('Camera scan successful â€” Step 1 autofilled âœ“', true);
    }, 650);
  }

  // â”€â”€ Engine 1: Native BarcodeDetector (rAF loop, full frame) â”€â”€
  async function nativeLoop() {
    if (!cameraStream) return;
    if (cameraFeed.readyState < 2) { scanLoopHandle = requestAnimationFrame(nativeLoop); return; }
    try {
      const results = await nativeDet.detect(cameraFeed);
      if (results.length) { onBarcode(results[0].rawValue); return; }
    } catch(_) {}
    scanLoopHandle = requestAnimationFrame(nativeLoop);
  }

  // â”€â”€ Engine 2: @zxing/browser BrowserPDF417Reader â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // This is the modern, maintained replacement for @zxing/library.
  // It uses the continuous video decode loop internally â€” no manual
  // canvas/BinaryBitmap wrangling needed, and it handles focus wait,
  // retry, and TRY_HARDER automatically.
  function startZXingBrowserLoop() {
    const ZXB = window.ZXingBrowser;
    if (!ZXB || !ZXB.BrowserPDF417Reader) {
      setScanMsg('Decoder library failed to load', 'bad');
      return;
    }

    // Hints: enable TRY_HARDER for dense SA ID barcodes
    const hints = new Map();
    hints.set(2 /* DecodeHintType.TRY_HARDER */, true);

    zxingReader = new ZXB.BrowserPDF417Reader(hints);

    // decodeFromVideoElement continuously decodes from the already-playing
    // video element. It resolves/rejects on first result or error.
    // We use the callback form so we get every frame attempt.
    zxingReader.decodeFromVideoElement(cameraFeed, (result, err) => {
      if (!cameraStream) return; // already stopped
      if (result) {
        onBarcode(result.getText());
      }
      // err here is just NotFoundException (no barcode in frame) â€” normal, ignore
    }).catch(err => {
      // Only surface real errors, not NotFoundException
      if (err && err.name !== 'NotFoundException') {
        setScanMsg(`Decoder error: ${err.message}`, 'bad');
      }
    });

    // scanLoopHandle holds the reader so stopCamera() can reset it
    scanLoopHandle = zxingReader;
  }

  // â”€â”€ Start / stop camera â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  async function startCamera() {
    $('cameraBtn').disabled = true;
    setScanMsg('Initialisingâ€¦');
    scanOverlay.classList.remove('hidden');

    try {
      setScanMsg('Loading decoderâ€¦');
      scanEngine = await pickEngine();
      setScanMsg(`Decoder ready (${scanEngine === 'native' ? 'BarcodeDetector' : 'ZXing'}). Requesting cameraâ€¦`);

      cameraStream = await navigator.mediaDevices.getUserMedia({
        video: {
          facingMode: { ideal: 'environment' },
          width:  { ideal: 1920 },
          height: { ideal: 1080 },
        },
        audio: false,
      });

      cameraFeed.srcObject = cameraStream;
      await cameraFeed.play();

      // Torch support
      torchTrack = cameraStream.getVideoTracks()[0];
      const caps = torchTrack?.getCapabilities?.() || {};
      torchBtn.style.display = caps.torch ? '' : 'none';

      setScanMsg('Point barcode at the frameâ€¦');

      if (scanEngine === 'native') {
        scanLoopHandle = requestAnimationFrame(nativeLoop);
      } else {
        startZXingBrowserLoop();
      }

    } catch (err) {
      stopCamera();
      let msg;
      if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') {
        if (location.protocol === 'file:') {
          msg = 'Camera blocked: browsers do not allow camera access on file:// URLs. ' +
                'Serve the page via a local server (e.g. "npx serve ." or "python -m http.server") ' +
                'and open http://localhost:&lt;port&gt; instead.';
        } else {
          msg = 'Camera permission denied. Please allow camera access in your browser settings and try again.';
        }
      } else if (err.name === 'NotFoundError') {
        msg = 'No camera found on this device.';
      } else if (err.name === 'NotReadableError') {
        msg = 'Camera is busy â€” close other apps using it and try again.';
      } else if (err.name === 'SecurityError') {
        msg = 'Camera blocked by browser security policy. Page must be served over HTTPS or localhost.';
      } else {
        msg = `Camera error (${err.name}): ${err.message}`;
      }
      setStatus(msg, false);
      $('cameraBtn').disabled = false;
    }
  }

  function stopCamera() {
    // Stop the active scan engine
    if (scanEngine === 'native' && scanLoopHandle) {
      cancelAnimationFrame(scanLoopHandle);
    } else if (scanEngine === 'zxing-browser' && zxingReader) {
      try { zxingReader.reset(); } catch(_) {}
      zxingReader = null;
    } else if (scanLoopHandle && typeof scanLoopHandle === 'number') {
      clearInterval(scanLoopHandle);
    }
    scanLoopHandle = null;

    if (cameraStream) { cameraStream.getTracks().forEach(t => t.stop()); cameraStream = null; }
    cameraFeed.srcObject = null;

    torchOn = false; torchBtn.classList.remove('lit');
    scanOverlay.classList.add('hidden');
    $('cameraBtn').disabled = false;
  }

  async function toggleTorch() {
    if (!torchTrack) return;
    torchOn = !torchOn;
    try {
      await torchTrack.applyConstraints({ advanced: [{ torch: torchOn }] });
      torchBtn.classList.toggle('lit', torchOn);
    } catch(_) { torchOn = !torchOn; }
  }

  $('cameraBtn').addEventListener('click', startCamera);
  $('closeScanBtn').addEventListener('click', stopCamera);
  torchBtn.addEventListener('click', toggleTorch);
  document.addEventListener('keydown', e => {
    if (e.key === 'Escape' && !scanOverlay.classList.contains('hidden')) stopCamera();
  });

  // â”€â”€ Google Places â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function parseAC(ac) {
    const get = t => { const c = (ac||[]).find(x => x.types?.includes(t)); return c ? c.long_name : ''; };
    return {
      streetNumber: get('street_number'),
      streetName:   get('route'),
      suburb:       get('sublocality')||get('sublocality_level_1')||get('neighborhood')||get('administrative_area_level_3')||'',
      cityTown:     get('locality')||get('postal_town')||get('administrative_area_level_2')||'',
      province:     get('administrative_area_level_1'),
      addrCountry:  get('country'),
      postalCode:   get('postal_code'),
    };
  }

  function fillAddress(d) {
    Object.entries({addrCountry:'addrCountry',streetNumber:'streetNumber',streetName:'streetName',
                    suburb:'suburb',cityTown:'cityTown',province:'province',postalCode:'postalCode'})
      .forEach(([k,id]) => { if (d[k]) $(id).value = d[k]; });
  }

  function loadGoogle(apiKey) {
    return new Promise((resolve, reject) => {
      if (!apiKey) {
        setPlacesStatus('Enter your Google Maps API key in Settings to enable address autofill', 'warn');
        resolve(false); return;
      }
      if (window.google?.maps) { resolve(true); return; }
      const s = document.createElement('script');
      s.src = `https://maps.googleapis.com/maps/api/js?key=${encodeURIComponent(apiKey)}&libraries=places`;
      s.async = true; s.defer = true;
      s.onload  = () => resolve(true);
      s.onerror = () => reject(new Error('Google Maps failed to load â€” check your API key'));
      document.head.appendChild(s);
    });
  }

  async function initPlaces(apiKey) {
    if (!await loadGoogle(apiKey)) return;
    placesAC  = new google.maps.places.Autocomplete(placesSearch, {
      fields: ['place_id','name','formatted_address','address_components']
    });
    placesSvc = new google.maps.places.PlacesService(document.createElement('div'));
    placesAC.addListener('place_changed', () => {
      const p = placesAC.getPlace(); if (!p) return;
      placesSearch.value = '';
      if (p.address_components?.length) { fillAddress(parseAC(p.address_components)); setPlacesStatus('Address autofilled âœ“', 'ok'); return; }
      if (!p.place_id) return;
      placesSvc.getDetails({ placeId: p.place_id, fields: ['address_components'] }, (d, st) => {
        if (st !== google.maps.places.PlacesServiceStatus.OK || !d) { setPlacesStatus(`Place details failed: ${st}`, 'bad'); return; }
        fillAddress(parseAC(d.address_components)); setPlacesStatus('Address autofilled âœ“', 'ok');
      });
    });
    setPlacesStatus('Address search ready', 'ok');
  }

  // â”€â”€ Button wiring â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  $('startBtn').addEventListener('click', () => {
    scanCapture.focus({ preventScroll: true });
    setStatus('Ready â€” scan with your external barcode scanner nowâ€¦', true);
  });
  $('clearBtn').addEventListener('click', clearAll);

  // â”€â”€ Scanbot SDK test button â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  $('scanbotBtn').addEventListener('click', async () => {
    const btn = $('scanbotBtn');
    btn.disabled = true;
    setStatus('Loading Scanbot SDKâ€¦', true);

    try {
      const sdk = await loadAndInitScanbot();
      setStatus('Scanbot ready â€” opening scannerâ€¦', true);

      // Configure the RTU barcode scanner for PDF417 only
      const config = new ScanbotSDK.UI.Config.BarcodeScannerScreenConfiguration();

      // Restrict to PDF_417 only for best performance on SA IDs
      config.scannerConfiguration.barcodeFormats = ['PDF_417'];

      // Wide viewfinder to match PDF417 aspect ratio
      config.viewFinder.aspectRatio.width  = 3;
      config.viewFinder.aspectRatio.height = 1;

      // Launch the full-screen Scanbot scanner UI
      const result = await ScanbotSDK.UI.createBarcodeScanner(config);

      if (result && result.items && result.items.length > 0) {
        const rawText = result.items[0].barcode.rawValue || result.items[0].barcode.text || '';
        if (rawText) {
          parseAndApply(rawText);
          setStatus('Scanbot scan successful â€” Step 1 autofilled âœ“', true);
        } else {
          setStatus('Scanbot: barcode detected but raw value was empty.', false);
        }
      } else {
        setStatus('Scanbot: no barcode detected â€” try again.', false);
      }
    } catch (err) {
      const msg = err && err.message ? err.message : String(err);
      // "LicenseError" after the 60s trial ends
      if (msg.toLowerCase().includes('license') || msg.toLowerCase().includes('trial')) {
        setStatus('Scanbot trial expired (60s limit). Reload the page to start a new session.', false);
      } else if (msg.toLowerCase().includes('cancel')) {
        setStatus('Scanbot scanner cancelled.', true);
      } else {
        setStatus(`Scanbot error: ${msg}`, false);
      }
    } finally {
      btn.disabled = false;
    }
  });
  $('nextStepBtn').addEventListener('click', () => setStep(2));
  $('backBtn').addEventListener('click', () => setStep(1));
  $('submitBtn').addEventListener('click', async () => {
    const p = {
      surname:$('surname').value.trim()||null, names:$('names').value.trim()||null,
      gender:$('gender').value||null, idNumber:$('idNumber').value.trim()||null,
      dob:$('dob').value.trim()||null, citizenship:$('citizenship').value.trim()||null,
      nationality:$('nationality').value.trim()||null, issueDate:$('issueDate').value.trim()||null,
      race:$('race').value||null, language:$('language').value||null,
      maritalStatus:$('maritalStatus').value||null,
      country:$('addrCountry').value.trim()||null, streetNumber:$('streetNumber').value.trim()||null,
      streetName:$('streetName').value.trim()||null, suburb:$('suburb').value.trim()||null,
      cityTown:$('cityTown').value.trim()||null, province:$('province').value.trim()||null,
      postalCode:$('postalCode').value.trim()||null,
    };
    payloadOut.textContent = JSON.stringify(p, null, 2);
    setStatus('Submitted â€” payload in Debug panel', true);

    const apiStatusEl = $('apiStatus');
    let authToken = null;
    let dbId      = null;

    try {
      const hashParams = new URLSearchParams((window.location.hash || '').replace(/^#/, ''));
      const enc = hashParams.get('enc');
      if (enc) {
        const creds = JSON.parse(xorDeobfuscate(enc));
        authToken   = creds.authToken;
        dbId        = creds.dbId;
      } else {
        authToken = hashParams.get('authToken');
        dbId      = hashParams.get('dbId');
      }
    } catch (e) {
      apiStatusEl.innerHTML = '<span class="bad">âœ— Failed to decode URL credentials â€” the enc= value may be corrupted.</span>';
      $('submitBtn').disabled = false;
      window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' });
      return;
    }

    if (authToken && dbId) {
      const endpoint = `https://appnostic.dbflex.net/secure/api/v2/${encodeURIComponent(dbId)}/Staffify/create.json`;
      apiStatusEl.innerHTML = '<span class="warn">Sending to DBFlexâ€¦</span>';
      $('submitBtn').disabled = true;
      try {
        const res = await fetch(endpoint, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${authToken}`
          },
          body: JSON.stringify(p)
        });
        const text = await res.text();
        let pretty = text;
        try { pretty = JSON.stringify(JSON.parse(text), null, 2); } catch (_) {}
        payloadOut.textContent = JSON.stringify(p, null, 2) + '\n\nâ”€â”€ DBFlex Response â”€â”€\n' + pretty;
        if (res.ok) {
          apiStatusEl.innerHTML = `<span class="ok">âœ“ Sent to DBFlex (HTTP ${res.status})</span>`;
        } else {
          apiStatusEl.innerHTML = `<span class="bad">âœ— DBFlex error: HTTP ${res.status} ${res.statusText}</span>`;
        }
      } catch (err) {
        apiStatusEl.innerHTML = `<span class="bad">âœ— Fetch error (CORS?): ${err && err.message ? err.message : String(err)}</span>`;
      } finally {
        $('submitBtn').disabled = false;
      }
    } else {
      apiStatusEl.innerHTML = '<span class="muted">No DBFlex credentials in URL â€” payload shown in Debug only. Add <code>#enc=â€¦</code> to the URL to enable posting.</span>';
    }

    window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' });
  });

  // â”€â”€ Settings: API key management â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function updateApiKeyBadge() {
    const badge = $('apiKeyBadge');
    if (getApiKey()) {
      badge.textContent = 'â— Key saved';
      badge.style.background = '#d4edda';
      badge.style.color = '#155724';
    } else {
      badge.textContent = 'â—‹ No key';
      badge.style.background = '#fff3cd';
      badge.style.color = '#856404';
    }
  }

  function setApiKeyStatus(msg, ok = true) {
    $('apiKeyStatus').innerHTML = `<span class="${ok ? 'ok' : 'bad'}">${msg}</span>`;
  }

  function loadApiKeyIntoInput() {
    const k = getApiKey();
    $('apiKeyInput').value = k || '';
  }

  $('apiKeyToggle').addEventListener('click', () => {
    const inp = $('apiKeyInput');
    const isHidden = inp.type === 'password';
    inp.type = isHidden ? 'text' : 'password';
    $('apiKeyToggle').textContent = isHidden ? 'ğŸ™ˆ' : 'ğŸ‘';
  });

  $('apiKeySave').addEventListener('click', async () => {
    const key = $('apiKeyInput').value.trim();
    if (!key) { setApiKeyStatus('Please enter an API key first.', false); return; }

    localStorage.setItem(LS_KEY, key);
    updateApiKeyBadge();
    setApiKeyStatus('Key saved!', true);

    if (!window.google?.maps) {
      setPlacesStatus('Loading Google Mapsâ€¦', 'ok');
      try {
        await initPlaces(key);
        setApiKeyStatus('Key saved & Google Maps activated âœ“', true);
        setPlacesStatus('Address search ready âœ“', 'ok');
      } catch(e) {
        setApiKeyStatus(`Error: ${e.message}`, false);
        setPlacesStatus(`Google Maps error: ${e.message}`, 'bad');
      }
    } else {
      try {
        await initPlaces(key);
        setApiKeyStatus('Key saved âœ“ (Maps already loaded)', true);
      } catch(e) {
        setApiKeyStatus(`Error: ${e.message}`, false);
      }
    }
  });

  $('apiKeyClear').addEventListener('click', () => {
    localStorage.removeItem(LS_KEY);
    $('apiKeyInput').value = '';
    updateApiKeyBadge();
    setApiKeyStatus('Key cleared. Address autofill disabled.', true);
    setPlacesStatus('Enter your Google Maps API key in Settings to enable address autofill', 'warn');
    placesAC = null; placesSvc = null;
  });

  // â”€â”€ Init â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  window.addEventListener('load', () => {
    loadApiKeyIntoInput();
    updateApiKeyBadge();
    if (!getApiKey()) $('settingsDetails').open = true;
    if (location.protocol === 'file:') {
      $('cameraBtn').disabled = true;
      $('cameraBtn').title = 'Camera is blocked on file:// URLs â€” serve via localhost instead';
      setStatus(
        'âš  Camera unavailable on file:// URLs. ' +
        'Run a local server (e.g. <code>npx serve .</code> or <code>python -m http.server</code>) ' +
        'and open <b>http://localhost:&lt;port&gt;</b> to enable camera scanning. ' +
        'The Scanner still works here.',
        false
      );
    } else if (!navigator.mediaDevices?.getUserMedia) {
      $('cameraBtn').disabled = true;
      $('cameraBtn').title = 'Camera API requires HTTPS and a compatible browser';
    }
    if (location.protocol !== 'file:') {
      setStatus('Tap "Scan with Camera" to scan, or use a keyboard barcode scanner.', true);
    }
    initPlaces(getApiKey()).catch(e => setPlacesStatus(`Google Maps error: ${e.message}`, 'bad'));
  });

})();
</script>

</body>
</html>